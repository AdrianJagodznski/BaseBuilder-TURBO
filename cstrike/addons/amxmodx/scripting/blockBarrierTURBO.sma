
/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <ColorChat>
#include <fakemeta>
#include <xs>

#define TASK_GOD 18242
#define MAXNUM 10
#define LENNAME 18

new const PREFIX[]="[BARRIER]^x03"

enum ( <<= 1 )
{
	B1 = 1,
	B2,
	B3,
	B4,
	B5,
	B6,
	B7,
	B8,
	B9,
	B0
};
new const PLUGIN[]= "Block barrier"
new const VERSION[]= "1.0"
new const AUTHOR[]= "Albertd & KoRrNiK & R3X"


new userListBarrier[33][MAXNUM]
new gBarrier[33];
new gBarrierColorOffset[33]
new gBarriers[MAXNUM];
new beam_spr;
new Float:userMoveFor[33]
new bool:userIsInBarrier[33]

new Float:userBuildBarrierOrigin[33][2][3]

new bool:croshh[33];
new const TASK_CROSS = 1250


new szFolder[32]
new szFile[64]

new const gszModel[] = "sprites/basebuildervt/boxsprite.spr";
public plugin_precache(){
	//beam_spr = precache_model("sprites/basebuilderT/barrierSprite.spr")
	beam_spr = precache_model("sprites/basebuildervt/whitenew.spr")
	precache_model("sprites/basebuildervt/barrierwall.spr")
	
	precache_model(gszModel);
}

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	register_think("blockBarrier", "barrierThink")	
	//register_touch("blockBarrier", "func_wall", "checkBarrier")
	register_clcmd("bb_barrier", "barrierSize")
	register_clcmd("bariera", "barieraRead")
	register_clcmd("jednostka", "moveRead")
	register_forward(FM_Touch, "fwd_touch")
	register_clcmd("Wartosc_Koloru", "readColor")

	
	register_forward(FM_TraceLine, "fwTraceLine", 1);
	register_forward(FM_PlayerPreThink, "fwPlayerPreThink", 1);
	
	register_menu("barrierSize",	B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | B9 | B0,	"barrierSize_2");
	register_menu("menuChangeSize",	B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | B9 | B0,	"menuChangeSize_2");
	
	new szMap[32]
	get_mapname(szMap, sizeof(szMap))
	get_configsdir(szFolder, sizeof(szFolder))			
	format(szFile,sizeof(szFile),"%s/Barrier/%s.bb", szFolder, szMap)
	loadBarrier()
}
public plugin_natives(){
	register_native("bb_is_in_barrier", "isInBarrier", 1)
}
public bool:isInBarrier(id){
	return userIsInBarrier[id]
}
public client_connect(id){
	gBarrier[id]=0
	userMoveFor[id]=32.0
}
public saveBarrier(id){
	new szData[128]
	new Float:fOrigin[3]
	new file = fopen(szFile, "wt")	
	if( file ){
		new ent =0;
		new szTargetName[LENNAME]
		new Float:fBarrierSizeMin[3],Float:fBarrierSizeMax[3]
		for( new i = 0 ; i< MAXNUM; i ++ ){
			ent=gBarriers[i]
			if( !isBarrier(ent)  )
				continue;
			pev(ent, pev_mins, fBarrierSizeMin)
			pev(ent, pev_maxs, fBarrierSizeMax)
			pev(ent, pev_targetname, szTargetName, sizeof(szTargetName))
			pev(ent, pev_origin, fOrigin)		
			
			format(szData, sizeof(szData), "x %f %f %f %0.1f %0.1f %0.1f %0.1f %0.1f %0.1f ^"%s^" %d %d %d %d ^n",
				fOrigin[0],fOrigin[1],fOrigin[2],
				fBarrierSizeMin[0],fBarrierSizeMin[1],fBarrierSizeMin[2],
				fBarrierSizeMax[0],fBarrierSizeMax[1],fBarrierSizeMax[2],
				szTargetName, pev(ent, pev_iuser1), pev(ent, pev_iuser2), pev(ent, pev_iuser3),
				( pev(ent, pev_solid) == SOLID_BBOX ? 1 : 0 )
			)
			fputs(file, szData)
			
		}
		fclose(file)
		ColorChat(id, GREEN, "%s Zapisano Bariery", PREFIX)
		

	}
}
public loadBarrier(){
	new szData[128]
	if( file_exists(szFile) ){	
		new x=0;
		new last=0;
		new file = fopen(szFile, "rt")
		
		new szChar[2]
		new szOrigin[3][17]
		new szSizeMin[3][9]
		new szSizeMax[3][9]
		new szTargetName[LENNAME]
		new Float:fSizeMin[3]
		new Float:fSizeMax[3]
		new colorBarrier[3][4]
		new szType[2]
		while( !feof(file) ){	
			fgets(file, szData, sizeof(szData));
			parse(szData, 
				szChar, sizeof(szChar),
				szOrigin[0], sizeof(szOrigin[]),
				szOrigin[1], sizeof(szOrigin[]),
				szOrigin[2], sizeof(szOrigin[]),
				szSizeMin[0], sizeof(szSizeMin[]),
				szSizeMin[1], sizeof(szSizeMin[]),
				szSizeMin[2], sizeof(szSizeMin[]),
				szSizeMax[0], sizeof(szSizeMax[]),
				szSizeMax[1], sizeof(szSizeMax[]),
				szSizeMax[2], sizeof(szSizeMax[]),
				szTargetName, sizeof(szTargetName),
				colorBarrier[0], sizeof(colorBarrier[]),
				colorBarrier[1], sizeof(colorBarrier[]),
				colorBarrier[2], sizeof(colorBarrier[]),
				szType, sizeof(szType)
				
			)
			
			
			new Float:fOrigin[3]
			for( new i = 0;i <3; i ++ )
				fOrigin[i]=str_to_float(szOrigin[i])
			for( new i = 0;i <3; i ++ )
				fSizeMin[i]=str_to_float(szSizeMin[i])
			
			for( new i = 0;i <3; i ++ )
				fSizeMax[i]=str_to_float(szSizeMax[i])
			
				
			new ent = createBarrier(fOrigin, fSizeMin, fSizeMax, str_to_num(szType))
			set_pev(ent, pev_targetname, szTargetName)
			if( str_to_num(colorBarrier[0]) + str_to_num(colorBarrier[1])+str_to_num(colorBarrier[2]) == 0 ){
				set_pev(ent, pev_iuser1, random(255))
				set_pev(ent, pev_iuser2, random(255))
				set_pev(ent, pev_iuser3, random(255))
			}else{
				set_pev(ent, pev_iuser1, str_to_num(colorBarrier[0]))
				set_pev(ent, pev_iuser2, str_to_num(colorBarrier[1]))
				set_pev(ent, pev_iuser3, str_to_num(colorBarrier[2]))
			}
			
			
			gBarriers[x++]=ent;
			last=ent;
				
		}
		
		if( last != 0 )
			remove_entity(last)
		fclose(file)
	}
	
	
}	

stock getOwner(ent)		return pev(ent, pev_iuser1) 
stock getMover(ent)		return pev(ent, pev_iuser3) 
stock getLock(ent)		return pev(ent, pev_iuser4)
stock getLastMover(ent)		return pev(ent, pev_iuser2)
public offBarrierGod(id){
	id-=TASK_GOD;
	userIsInBarrier[id] = false;
}
public fwd_touch(toucher, touched){
	
	
	if( !pev_valid(toucher) || !pev_valid(touched) || touched == 0 || toucher == 0 )
		return PLUGIN_CONTINUE
	new szClassEnt_1[33], szClassEnt_2[33]
	pev(toucher, pev_classname, szClassEnt_1, sizeof(szClassEnt_1) )
	pev(touched, pev_classname, szClassEnt_2, sizeof(szClassEnt_2) )
	
	
	if( entity_get_int(toucher, EV_INT_solid) != SOLID_TRIGGER ) 
		return PLUGIN_CONTINUE
	
	if( equal(szClassEnt_1, "blockBarrier") ){
			
		if( equal(szClassEnt_2, "grenade") ){
			if( pev(touched, pev_iuser1) == 0){
				new Float:fVelocity[3]
				pev(touched, pev_velocity, fVelocity)
				fVelocity[0] *= -1;
				fVelocity[1] *= -1;
				fVelocity[2] *= -1;
				set_pev(touched, pev_velocity, fVelocity)
				set_pev(touched, pev_iuser1, 1)
				
			}
		}
		if(equal(szClassEnt_2, "player")){
			if( get_user_team(touched) == 1 && is_user_alive(touched)){
				if( task_exists(touched+TASK_GOD) ){
					remove_task(touched+TASK_GOD)
				}
				set_task(0.1, "offBarrierGod", touched+TASK_GOD)
				userIsInBarrier[touched]=true
			}
		}
	}
		
	if( !equal(szClassEnt_1, "blockBarrier") && !equal(szClassEnt_1, "func_wall"))
		return PLUGIN_CONTINUE
	
		
	if( !equal(szClassEnt_2, "func_wall")  ){		
		return PLUGIN_CONTINUE
	}

	if( equal(szClassEnt_2, "func_wall" ) && equal(szClassEnt_1, "func_wall") && getLock(toucher) != 2)
		return PLUGIN_CONTINUE
	
	
	if( getOwner(touched) != 0 ){	
		if(  getMover(touched) == 0  ){
			new Float:fOrigin[3]
			entity_get_vector(touched, EV_VEC_vuser4, fOrigin)
			if( fOrigin[0] != 0.0 || fOrigin[1] != 0.0 || fOrigin[2] != 0.0 ){
				ColorChat(getLastMover(touched), GREEN, "---^x01 Klocek cofniety!^x04 |^x01 Nie wsadzaj klocka w bariere!^x04 ---")
				entity_set_origin(touched, fOrigin)
			}else{
				//bb_set_claimed(getOwner(touched), bb_get_claimed(getOwner(touched))-1)
				
				if( getLock(touched) == 3 ){
					new szClass[10], szTarget[7];
					entity_get_string(touched, EV_SZ_classname, szClass, 9);
					entity_get_string(touched, EV_SZ_targetname, szTarget, 6);
						
						
					if( !equal(szClass, "func_wall")) 
						return PLUGIN_CONTINUE
					if( equal(szTarget, "ignore") )
						return PLUGIN_CONTINUE
					if( equal(szTarget, "barrier") )
						return PLUGIN_CONTINUE					
					if( equal(szClass, "blockBarrier") )
						return PLUGIN_CONTINUE
					
					remove_entity(touched)
				}else{
					set_pev(touched, pev_iuser1, 0) 
					entity_set_origin(touched, Float:{0.0,0.0,0.0});
				}
			}
			
		}else{			
			set_pev(touched,pev_rendermode,kRenderTransColor)
			set_pev(touched,pev_rendercolor, Float:{255.0,0.0,0.0} )
			set_pev(touched,pev_renderamt, 255.0 )
			set_task(0.1, "checkRemove", touched)
		}
	}
	return PLUGIN_CONTINUE
} 
public checkRemove(ent){
	if( !pev_valid(ent) )
		return PLUGIN_CONTINUE
	if(  getMover(ent) == 0  ){		
		set_pev(ent,pev_rendermode,kRenderNormal)	
	}else{		
		new Float:fColors[3]		
		pev(ent,pev_vuser2,fColors)
		set_pev(ent,pev_rendermode,kRenderTransColor)
		set_pev(ent,pev_rendercolor, fColors )
		set_pev(ent,pev_renderamt, 200.0 )
		
	}
	return PLUGIN_CONTINUE
}
public isBarrier(ent){	
	if( !pev_valid(ent) )
		return 0;
	new szClass[LENNAME]
	pev(ent, pev_classname, szClass, sizeof(szClass) )
	if( !equal(szClass, "blockBarrier") )
		return 0;
	return 1;
}
public barieraRead(id){
	new szArg[LENNAME]
	read_argv(1, szArg, sizeof(szArg))
	remove_quotes(szArg)
	
	new ent=gBarriers[gBarrier[id]]
	if( !isBarrier(ent) ){
		return PLUGIN_CONTINUE
	}
	ColorChat(id, GREEN, "%s Zminiono nazwe na:^x04 %s", PREFIX, szArg)
	set_pev(ent, pev_targetname, szArg)
	return PLUGIN_CONTINUE
		
}
public moveRead(id){
	new szArg[LENNAME]
	read_argv(1, szArg, sizeof(szArg))
	remove_quotes(szArg)	
	userMoveFor[id]=floatabs(str_to_float(szArg))
	ColorChat(id, GREEN, "%s Zmieniles jednostke na:^x04 %0.1f", PREFIX, userMoveFor[id])		
}
public setColors(id){
	new ent = gBarriers[gBarrier[id]]
	if( !isBarrier(ent) )
		return;
	pev(ent, pev_iuser1, 0)
	pev(ent, pev_iuser2, 0)
	pev(ent, pev_iuser3, 0)
	gBarrierColorOffset[id]=0;
	client_cmd(id, "messagemode Wartosc_Koloru")
}
public readColor(id){
	new ent = gBarriers[gBarrier[id]]
	if( !isBarrier(ent) )
		return;
	if( !has_flag(id, "a" ) )
		return;
	
	new szArg[7]
	read_argv(1, szArg, sizeof(szArg)-3)
	
	new color = str_to_num(szArg)%256
	
	switch(gBarrierColorOffset[id]){
		case 0:{
			set_pev(ent, pev_iuser1, color)
			client_cmd(id, "messagemode Wartosc_Koloru")
		}
		case 1:{
			set_pev(ent, pev_iuser2, color)			
			client_cmd(id, "messagemode Wartosc_Koloru")
		}
		case 2:{
			set_pev(ent, pev_iuser3, color)			
		}
	}
	gBarrierColorOffset[id]++;
	barrierSize(id)
	return;
	
}
public barrierSize(id){
	if( !has_flag(id, "d" ) )
		return PLUGIN_CONTINUE
	new gText[356], ilen=0
	
	ilen += format(gText[ilen], sizeof(gText)-ilen-1, "\r[BaseBuilder]\y Barriera")
	ilen += format(gText[ilen], sizeof(gText)-ilen-1, "^n\r1.\w Zmien Rozmiar")
	ilen += format(gText[ilen], sizeof(gText)-ilen-1, "^n\r2.\w Przesuwanie")
	
	new ent = gBarriers[gBarrier[id]]
	if( isBarrier(ent) ){
		new szTargetName[LENNAME]
		pev(ent, pev_targetname, szTargetName, sizeof(szTargetName))
		ilen += format(gText[ilen], sizeof(gText)-ilen-1, "^n\r3.\w Nazwa:\y %s", szTargetName)
	}else ilen += format(gText[ilen], sizeof(gText)-ilen-1, "^n\r3.\w Nazwa:\y Nie wybrano")
	
	
	new numBarrier=0;
	for( new i = 0; i<MAXNUM; i++){
		if( !isBarrier(gBarriers[i] )) 
			continue;
		numBarrier++
	}
	ilen += format(gText[ilen], sizeof(gText)-ilen-1, "^n\r4.\w Lista Barrier:\y #%d/%d", numBarrier, MAXNUM)
		
	
	if( isBarrier(ent) )
		ilen += format(gText[ilen], sizeof(gText)-ilen-1, "^n\r5.\w Zmien rodzaj barriery:\y %s", entity_get_int(ent, EV_INT_solid) == SOLID_TRIGGER ? "SOLID_NOT" : "SOLID_BBOX")		
	else ilen += format(gText[ilen], sizeof(gText)-ilen-1, "^n\d5. Zmien rodzaj barriery: NONE");
	ilen += format( gText[ilen], sizeof(gText)-ilen-1, "^n\r6.\w Zapisz/Wczytaj")	
	if( isBarrier(ent) ){
		ilen += format( gText[ilen], sizeof(gText)-ilen-1, "^n\r7.\w Kolor: [\r%d %d %d\w]", pev(ent, pev_iuser1), pev(ent, pev_iuser2), pev(ent, pev_iuser3))	
	}else ilen += format( gText[ilen], sizeof(gText)-ilen-1, "^n\d7. Kolor")
	if( isBarrier(ent) ){
		new szTargetName[LENNAME]
		pev(ent, pev_targetname, szTargetName, sizeof(szTargetName))
		ilen += format( gText[ilen], sizeof(gText)-ilen-1, "^n\r8.\w Usun:\y %s",szTargetName)			
	}else ilen += format( gText[ilen], sizeof(gText)-ilen-1, "^n\d8. Usun:\y Nie wybrano")	
	ilen += format( gText[ilen], sizeof(gText)-ilen-1, "^n\r9.\w Jednostka:\y %0.1f", userMoveFor[id])	
	ilen += format( gText[ilen], sizeof(gText)-ilen-1, "^n^n\r0.\w Wyjdz")
	show_menu(id, B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | B9 | B0, gText, -1, "barrierSize")	
	return PLUGIN_CONTINUE
}
public barrierSize_2(id, item){
	
	switch(item){
		case 0:{
			menuChangeSize(id)
		}
		case 1:{
			menuMove(id)
		}
		case 2:{
			client_cmd(id, "messagemode bariera")
			barrierSize(id)
		}
		case 3:{
			menuListBarrier(id)
		}
		case 4:{
			
		
			new ent = gBarriers[gBarrier[id]];
			
			
			
			if( ent == 0 || !pev_valid(ent) ){
				barrierSize(id)
				return PLUGIN_CONTINUE
			}
			if( !isBarrier(ent) ){
				barrierSize(id)
				return PLUGIN_CONTINUE
			}
			new Float:fOrigin[3]
			pev(ent, pev_origin, fOrigin)
	
			new Float:fBarrierSizeMin[3],Float:fBarrierSizeMax[3]
			pev(ent, pev_mins, fBarrierSizeMin)
			pev(ent, pev_maxs, fBarrierSizeMax)	
				
			if( entity_get_int(ent, EV_INT_solid) == SOLID_TRIGGER ){
				
				entity_set_model(ent, "sprites/basebuildervt/barrierwall.spr")
				entity_set_int(ent, EV_INT_rendermode, 5)
				entity_set_float(ent, EV_FL_renderamt, 155.0)
				entity_set_float(ent, EV_FL_scale, 0.5)
				entity_set_int(ent, EV_INT_solid, SOLID_BBOX)		
				
				
			}else{
				entity_set_int(ent, EV_INT_solid, SOLID_TRIGGER)
			
			}
			
			engfunc( EngFunc_SetSize, ent , fBarrierSizeMin, fBarrierSizeMax );
			barrierSize(id)
		}
		case 5:{
			saveLoadMenu(id)	
			
		}
		case 6:{
			setColors(id)
		}
		case 7:{
			if( gBarriers[gBarrier[id]] == 0 )
				return PLUGIN_CONTINUE
			remove_entity(gBarriers[gBarrier[id]])
			gBarriers[gBarrier[id]]=0
			gBarrier[id]=0;
			barrierSize(id)
		}
		case 8:{
			client_cmd(id, "messagemode jednostka")
			barrierSize(id)
		}
		
	}	
	return PLUGIN_CONTINUE
}
public saveLoadMenu(id){
	new gText[128]
	new menu = menu_create("Wybierz akcje:", "saveLoadMenu_2")
	
	menu_additem(menu, "Zapisz")
	menu_additem(menu, "Wczytaj")
	
	new numBarrier=0;
	for( new i = 0; i<MAXNUM; i++){
		if( !isBarrier(gBarriers[i] )) 
			continue;
		numBarrier++
	}
	
	format(gText, sizeof(gText), "%sDodaj Barriere",numBarrier == MAXNUM?"\d":"\w")		
	menu_additem(menu, gText)
	
	menu_display(id, menu, 0)
	
}
public saveLoadMenu_2(id,menu,item){
	if( item == MENU_EXIT ){
		barrierSize(id)
		return PLUGIN_HANDLED
	}
	switch(item){
		case 0:{
			saveBarrier(id)
			barrierSize(id)
		}
		case 1:{
			for( new i = 0 ;i < MAXNUM; i ++ ){
				new ent = gBarriers[i]
				
				gBarriers[i]=0;
				if( !isBarrier(ent) )
					continue;
				if( ent == 0 )
					continue;
				
				remove_entity(ent)
			}
			loadBarrier()
			
			ColorChat(id, GREEN, "%s Wczytano Bariery", PREFIX)
			
			barrierSize(id)
		}
		case 2:{/*
			new free=-1;
			new numBarrier=0;
			for( new i = 0; i<MAXNUM; i++){
				
				if( gBarriers[i] == 0 && free == -1 )
					free=i
				if( !isBarrier( gBarriers[i] )) 
					continue;
				
				numBarrier++
			}
			if( free != -1 && numBarrier < MAXNUM ){
				gBarriers[free] = createBarrierPlayer(id)
				gBarrier[id]=free;
			}else{
				ColorChat(id, GREEN, "%s Postawiono maxymalna ilosc barrier", PREFIX)
			}
			barrierSize(id)*/
			menuCreateBarrier(id)
		}
	}
	return PLUGIN_CONTINUE
}
public menuListBarrier(id){
	new gText[128]
	new menu=menu_create("\r[BaseBuilder]\y Bariery", "menuListBarrier_2")
	for( new i = 0,x=0; i<MAXNUM; i ++ ){
		new ent = gBarriers[i]
		if( !isBarrier(ent) )
			continue;
		new szTargetName[LENNAME]
		pev(ent, pev_targetname, szTargetName, sizeof(szTargetName) )
		format(gText, sizeof(gText), "Bariera:\y %s | #%d", szTargetName, ent)
		menu_additem(menu, gText)
		userListBarrier[id][x++]=i;
	}
	menu_display(id, menu, 0)
	
}
public menuListBarrier_2(id, menu, item ){
	if( item == MENU_EXIT) {
		menu_destroy(menu)
		return PLUGIN_CONTINUE
	}
	new line = userListBarrier[id][item]
	gBarrier[id] = line
	barrierSize(id)
	return PLUGIN_CONTINUE
}
public createBarrierPlayer(id){
	new Float:fOrigin[3]
	entity_get_vector(id, EV_VEC_origin, fOrigin)
	
	return createBarrier(fOrigin, Float:{-32.0,-32.0,-32.0}, Float:{32.0, 32.0, 32.0}, 0)
}


public createBarrier(Float:fOrigin[3], Float:fSizeMin[3], Float:fSizeMax[3], type){
	
	new ent = create_entity("info_target")
	if( !pev_valid(ent) )
		return 0;

	entity_set_string(ent, EV_SZ_classname, "blockBarrier")	

	entity_set_int(ent, EV_INT_movetype, MOVETYPE_NONE);	
	if( type == 0 ){
		entity_set_int(ent, EV_INT_solid, SOLID_TRIGGER)
	}else {
		entity_set_int(ent, EV_INT_solid, SOLID_BBOX)		
		entity_set_model(ent, "sprites/basebuildervt/barrierwall.spr")
		entity_set_int(ent, EV_INT_rendermode, 5)
		entity_set_float(ent, EV_FL_renderamt, 155.0)
	}
	changeSize(ent, fSizeMin, fSizeMax)
	entity_set_origin(ent, fOrigin)
	entity_set_string(ent, EV_SZ_targetname, "Nowa Bariera")
	
	set_pev(ent, pev_iuser1, 50)
	set_pev(ent, pev_iuser2, 150)
	set_pev(ent, pev_iuser3, 150)
	
	entity_set_float(ent, EV_FL_nextthink, get_gametime()+0.01)	
	return ent;
}


new userEditing
public menuCreateBarrier(id){
	
	croshh[id] = true;
	new gText[512];
	new iLen = 0
	iLen += format(gText[iLen], sizeof(gText)-1-iLen, "\d[Pozycja 1]:^t^t\rX\d (\y%d\d)^t^t^t^t\rY\d (\y%d\d)^t^t^t^t\rZ\d (\y%d\d)^n", floatround(userBuildBarrierOrigin[id][1][0]), floatround(userBuildBarrierOrigin[id][1][1]), floatround(userBuildBarrierOrigin[id][1][2]));

	iLen += format(gText[iLen], sizeof(gText)-1-iLen, "\d[Pozycja 2]:^t^t\rX\d (\y%d\d)^t^t^t^t\rY\d (\y%d\d)^t^t^t^t\rZ\d (\y%d\d)", floatround(userBuildBarrierOrigin[id][0][0]), floatround(userBuildBarrierOrigin[id][0][1]), floatround(userBuildBarrierOrigin[id][0][2]));
	
	new menu = menu_create(gText, "menuCreateBarrier_2");

	menu_additem(menu, "\wZaznacz pozycje\d (\r 1 - Celownik\d )")
	menu_additem(menu, "\wZaznacz pozycje\d (\r 2 - Celownik\d )")
	menu_additem(menu, "\wZaznacz pozycje\d (\r 1 - Twoja Pozycja\d )")
	menu_additem(menu, "\wZaznacz pozycje\d (\r 2 - Twoja Pozycja\d )^n")
	menu_additem(menu, "\wStworz Bariere\d (\r Pozycje\d )")
	menu_additem(menu, "\wStworz Bariere\d (\r Tam gdzie stoisz\d )")
	
	format(gText, sizeof(gText), "\wEDYCJA: %s", userEditing ? "\rON" : "\dOFF");
	menu_additem(menu, gText)
	
	
	menu_setprop(menu, MPROP_EXITNAME, "Wroc");
	
	menu_display(id, menu, 0);


	if(!task_exists(id + TASK_CROSS) && croshh[id])
		set_task(0.1, "crosshair", id + TASK_CROSS)
}

public crosshair(id){
	id -= TASK_CROSS;
	
	if(!croshh[id])	return PLUGIN_CONTINUE;
	
	set_hudmessage(85, 255, 170, -1.0, -1.0, 0, 0.0, 0.5, 0.01, 0.02)
	show_hudmessage(id, "+")
	
	set_task(0.5, "crosshair", id + TASK_CROSS)
		
	return PLUGIN_CONTINUE;
}


public menuCreateBarrier_2(id, menu, item){
	if(item == MENU_EXIT){
		croshh[id] = false;
		userEditing = false;
		
		BOX_RemoveAnchors()
		
				
		remove_task(id + TASK_CROSS)
		barrierSize(id)
		return PLUGIN_CONTINUE;
	}
	
	new Float:fOrigin[3]
	entity_get_vector(id, EV_VEC_origin, fOrigin)
	
	
	new button = pev(id, pev_button)	
	new flags = pev(id, pev_flags);
	
	new Float:flPointOrigin[3], flUserOrigin[3]
	get_user_origin(id, flUserOrigin, 3)
	IVecFVec(flUserOrigin, flPointOrigin)
	
	//for(new i = 0; i < 3; i++)
	///	userBuildBarrierOrigin[id][userBuildStage[id]][i] = flPointOrigin[i]

	
	
	switch(item){
		case 0:{
			new color[3]
			color[0] = 255
			color[1] = 0
			color[2] = 0
			
			get_user_origin(id, flUserOrigin, 3)
			IVecFVec(flUserOrigin, flPointOrigin)
			
			drawBeamLine(id, color)
			for(new i = 0; i < 3; i++)
				userBuildBarrierOrigin[id][1][i] = flPointOrigin[i]
			menuCreateBarrier(id)
		}
		case 1:{
			new color[3]
			color[0] = 0
			color[1] = 255
			color[2] = 0
			
			get_user_origin(id, flUserOrigin, 3)
			IVecFVec(flUserOrigin, flPointOrigin)
			
			drawBeamLine(id, color)
			for(new i = 0; i < 3; i++)
				userBuildBarrierOrigin[id][0][i] = flPointOrigin[i]
			menuCreateBarrier(id)
			
	
			
		}
		case 2:{
			
			get_user_origin(id, flUserOrigin)
			IVecFVec(flUserOrigin, flPointOrigin)
			
			for(new i = 0; i < 3; i++){
				userBuildBarrierOrigin[id][1][i] = flPointOrigin[i]
				
				if(flags & FL_ONGROUND){
					if((button & IN_DUCK))
						flPointOrigin[2] -= 9.0
					else flPointOrigin[2] -= 18.0
				}
			}
			menuCreateBarrier(id)	
		}
		case 3:{
			
			get_user_origin(id, flUserOrigin)
			IVecFVec(flUserOrigin, flPointOrigin)
			
			
			for(new i = 0; i < 3; i++){
				userBuildBarrierOrigin[id][0][i] = flPointOrigin[i]
			
				if(flags & FL_ONGROUND){
					if((button & IN_DUCK))
						flPointOrigin[2] -= 9.0
					else flPointOrigin[2] -= 18.0
				}
			}
			
				
			menuCreateBarrier(id)
		}
		case 4:{
			if(
				userBuildBarrierOrigin[id][1][0] == 0.0 && userBuildBarrierOrigin[id][1][1] == 0.0 && userBuildBarrierOrigin[id][1][2] == 0.0 ||
				userBuildBarrierOrigin[id][0][0] == 0.0 && userBuildBarrierOrigin[id][0][1] == 0.0 && userBuildBarrierOrigin[id][0][2] == 0.0
			){
				ColorChat(id, GREEN, "%s Podaj pozycje!", PREFIX)
				menuCreateBarrier(id)
				return PLUGIN_CONTINUE;
			}
			
			new Float:flFirstPoint[3], Float:flSecondPoint[3]
		
			for(new i = 0; i < 3; i++)
				flFirstPoint[i] = userBuildBarrierOrigin[id][0][i]
			for(new i = 0; i < 3; i++)
				flSecondPoint[i] = userBuildBarrierOrigin[id][1][i]
			
			
			new  Float:flSize[3]
			for(new i; i < 3; i++)
			{
				fOrigin[i] = (flFirstPoint[i] + flSecondPoint[i]) / 2.0
				flSize[i] = (flFirstPoint[i] > flSecondPoint[i]) ? (flFirstPoint[i] - flSecondPoint[i]) : (flSecondPoint[i] - flFirstPoint[i])
				
				
				
				
				userBuildBarrierOrigin[id][0][i] = flSize[i] / -2.0
				userBuildBarrierOrigin[id][1][i] = flSize[i] / 2.0
			}
			
			new free=-1;
			new numBarrier=0;
			for( new i = 0; i<MAXNUM; i++){
				
				if( gBarriers[i] == 0 && free == -1 )
					free=i
				if( !isBarrier( gBarriers[i] )) 
					continue;
				
				numBarrier++
			}
			if( free != -1 && numBarrier < MAXNUM ){
				gBarriers[free] = createBarrier(fOrigin,  userBuildBarrierOrigin[id][0], userBuildBarrierOrigin[id][1],0)
				gBarrier[id]=free;
			}else{
				ColorChat(id, GREEN, "%s Postawiono maxymalna ilosc barrier", PREFIX)
			}
			
			menuCreateBarrier(id)
			
			for(new i = 0; i < 3; i++)
				userBuildBarrierOrigin[id][1][i] = 0.0
			for(new i = 0; i < 3; i++)
				userBuildBarrierOrigin[id][0][i] = 0.0
		}
		case 5:{
			
			userEditing = false;
			BOX_RemoveAnchors()
				
			new free=-1;
			new numBarrier=0;
			for( new i = 0; i<MAXNUM; i++){
				
				if( gBarriers[i] == 0 && free == -1 )
					free=i
				if( !isBarrier( gBarriers[i] )) 
					continue;
				
				numBarrier++
			}
			if( free != -1 && numBarrier < MAXNUM ){
				gBarriers[free] = createBarrierPlayer(id)
				gBarrier[id]=free;
			}else{
				ColorChat(id, GREEN, "%s Postawiono maxymalna ilosc barrier", PREFIX)
			}
			menuCreateBarrier(id)
		}
		case 6:{
			new ent = gBarriers[gBarrier[id]];
			
			userEditing =! userEditing
			
			
			if(!userEditing)
				BOX_RemoveAnchors()
			else BOX_CreateAnchors(ent);
			
			menuCreateBarrier(id)
		}
	}
	return PLUGIN_CONTINUE;
}
public barrierThink(ent){
	if( !pev_valid(ent) )
		return 0;
	
	drawBoxModel(ent)
	
	if(userEditing)
		set_pev(ent, pev_nextthink, get_gametime()+(0.1))
	else set_pev(ent, pev_nextthink, get_gametime()+(0.5))
	
	return 1;
}
public drawBoxModel(ent){
	new color[3]
	
	if((pev(ent, pev_iuser1) + pev(ent, pev_iuser2) + pev(ent, pev_iuser3) ) == 0){
		color[0] = random(255)
		color[1] = random(255)
		color[2] = random(255)
	} else {
		color[0] = pev(ent, pev_iuser1)
		color[1] = pev(ent, pev_iuser2)
		color[2] = pev(ent, pev_iuser3)
	}
	
	new Float:fOrigin[3]	
	new Float:fMaxs[3], Float:fMins[3]	
	entity_get_vector(ent, EV_VEC_origin, fOrigin)
	entity_get_vector(ent, EV_VEC_mins, fMins)
	entity_get_vector(ent, EV_VEC_maxs, fMaxs)
	new Float:Point[8][3]
	
	Point[0][0] = fOrigin[0]-fMins[0]
	Point[0][1] = fOrigin[1]-fMins[1]
	Point[0][2] = fOrigin[2]-fMins[2]
		
	Point[1][0] = fOrigin[0]+fMins[0]
	Point[1][1] = fOrigin[1]-fMins[1]
	Point[1][2] = fOrigin[2]-fMins[2]
	drawLine(Point[0], Point[1], color)
		
	Point[2][0] = fOrigin[0]+fMins[0]
	Point[2][1] = fOrigin[1]+fMins[1]
	Point[2][2] = fOrigin[2]-fMins[2]
	drawLine(Point[1], Point[2], color)
		
	Point[3][0] = fOrigin[0]-fMins[0]
	Point[3][1] = fOrigin[1]+fMins[1]
	Point[3][2] = fOrigin[2]-fMins[2]
	drawLine(Point[2], Point[3], color)
	drawLine(Point[3], Point[0], color)
	
	Point[4][0] = fOrigin[0]-fMaxs[0]
	Point[4][1] = fOrigin[1]-fMaxs[1]
	Point[4][2] = fOrigin[2]-fMaxs[2]
		
	Point[5][0] = fOrigin[0]+fMaxs[0]
	Point[5][1] = fOrigin[1]-fMaxs[1]
	Point[5][2] = fOrigin[2]-fMaxs[2]
	drawLine(Point[4], Point[5], color)
		
	Point[6][0] = fOrigin[0]+fMaxs[0]
	Point[6][1] = fOrigin[1]+fMaxs[1]
	Point[6][2] = fOrigin[2]-fMaxs[2]
	drawLine(Point[5], Point[6], color)
		
	Point[7][0] = fOrigin[0]-fMaxs[0]
	Point[7][1] = fOrigin[1]+fMaxs[1]
	Point[7][2] = fOrigin[2]-fMaxs[2]
	drawLine(Point[6], Point[7], color)
	drawLine(Point[7], Point[4], color)
		
	drawLine(Point[0], Point[6], color)
	drawLine(Point[1], Point[7], color)
	drawLine(Point[2], Point[4], color)
	drawLine(Point[3], Point[5], color)
	
}
public drawLine(Float:fOriginStart[3], Float:fOriginEnd[3], color[3]){
	message_begin(MSG_BROADCAST,SVC_TEMPENTITY) 
	write_byte(TE_BEAMPOINTS)
	engfunc(EngFunc_WriteCoord,fOriginStart[0])
	engfunc(EngFunc_WriteCoord,fOriginStart[1])
	engfunc(EngFunc_WriteCoord,fOriginStart[2])
	engfunc(EngFunc_WriteCoord,fOriginEnd[0])
	engfunc(EngFunc_WriteCoord,fOriginEnd[1])
	engfunc(EngFunc_WriteCoord,fOriginEnd[2])
	write_short(beam_spr)
	write_byte(0)
	write_byte(0)
	if(userEditing)
		write_byte(1) // czas
	else write_byte(5) // czas
	
	write_byte(10) // grubosc
	write_byte(0) // gibu gibu 
	
	
	
	write_byte(color[0])
	write_byte(color[1])
	write_byte(color[2])
	
	write_byte(255)
	write_byte(1)
	message_end()
}
public drawBeamLine(id, color[3]){
	new iUserOrigin[3], iPointOrigin[3]
	get_user_origin(id, iUserOrigin)
	get_user_origin(id, iPointOrigin, 3)
		
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(TE_BEAMPOINTS)
	write_coord(iUserOrigin[0])
	write_coord(iUserOrigin[1])
	write_coord(iUserOrigin[2])
	write_coord(iPointOrigin[0])
	write_coord(iPointOrigin[1])
	write_coord(iPointOrigin[2])
	write_short(beam_spr)
	write_byte(0)
	write_byte(0)
	write_byte(5) 
	write_byte(3) 
	write_byte(0)
	write_byte(color[0])
	write_byte(color[1])
	write_byte(color[2])
	write_byte(255)
	write_byte(15)
	message_end()	
}

public bool:changeSize(ent, Float:fBarrierSizeMin[3], Float:fBarrierSizeMax[3]){
	if( (fBarrierSizeMin[0] > 0.0 || fBarrierSizeMin[1] > 0.0 || fBarrierSizeMin[2] > 0.0 ) &&
	(fBarrierSizeMax[0] < 0.0 || fBarrierSizeMax[1] < 0.0 || fBarrierSizeMax[2] < 0.0 ) ){
		return false;
	}
	
	engfunc( EngFunc_SetSize, ent , fBarrierSizeMin, fBarrierSizeMax );
	return true;
}
public menuChangeSize(id){
	new gText[256]
	format(gText, sizeof(gText),"\r[BaseBuilder]\y Menu Rozmiaru^n\
		^n\r1.\w Zwieksz Barriere\
		^n\r2.\w Zwieksz Wysokosc\
		^n\r3.\w Zmniejsz Barriere\
		^n\r4.\w Zmniejsz Wysokosc\
		^n\r5.\w Zwieksz\r X\
		^n\r6.\w Zmniejsz\r X\
		^n\r7.\w Zwieksz\r Y\
		^n\r8.\w Zmniejsz\r Y\
		^n^n\r0.\w Wyjdz\
	")
	
	show_menu(id, B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | B0, gText, -1, "menuChangeSize")
}
public menuChangeSize_2(id, item){
	
	new Float:fBarrierSizeMin[3],Float:fBarrierSizeMax[3]
	pev(gBarriers[gBarrier[id]], pev_mins, fBarrierSizeMin)
	pev(gBarriers[gBarrier[id]], pev_maxs, fBarrierSizeMax)
	switch(item){
		case 0:{
			fBarrierSizeMin[0]-=userMoveFor[id]
			fBarrierSizeMin[1]-=userMoveFor[id]
			fBarrierSizeMax[0]+=userMoveFor[id]
			fBarrierSizeMax[1]+=userMoveFor[id]
		}
		case 1:{
			fBarrierSizeMin[2]-=userMoveFor[id]
			fBarrierSizeMax[2]+=userMoveFor[id]
		}
		case 2:{
			fBarrierSizeMin[0]+=userMoveFor[id]
			fBarrierSizeMin[1]+=userMoveFor[id]
			fBarrierSizeMax[0]-=userMoveFor[id]
			fBarrierSizeMax[1]-=userMoveFor[id]
		}
		case 3:{
			fBarrierSizeMin[2]+=userMoveFor[id]
			fBarrierSizeMax[2]-=userMoveFor[id]
		}
		case 4:{
			fBarrierSizeMin[0]-=userMoveFor[id]
			fBarrierSizeMax[0]+=userMoveFor[id]		
		}
		case 5:{
			fBarrierSizeMin[0]+=userMoveFor[id]
			fBarrierSizeMax[0]-=userMoveFor[id]		
		}
		case 6:{
			fBarrierSizeMin[1]-=userMoveFor[id]
			fBarrierSizeMax[1]+=userMoveFor[id]		
		}
		case 7:{
			fBarrierSizeMin[1]+=userMoveFor[id]
			fBarrierSizeMax[1]-=userMoveFor[id]	
		}
	}
	if( item < 8 )		
		if( !changeSize( gBarriers[gBarrier[id]] , fBarrierSizeMin, fBarrierSizeMax) )
			ColorChat(id, GREEN, "[BARRIER]^x03 Nie prawidlowa wielkosc")
	if( item >7 )
		barrierSize(id)
	else menuChangeSize(id)
	return PLUGIN_CONTINUE
}
public menuMove(id){
	new menu=menu_create("\r[BaseBuilder]\y Przesuwanie", "menuMove_2")
	menu_additem(menu, "Przesun X+")	
	menu_additem(menu, "Przesun \rX-")	
	menu_additem(menu, "Przesun Y+")	
	menu_additem(menu, "Przesun \rY-")	
	menu_additem(menu, "Przesun w gore")	
	menu_additem(menu, "Przesun w dol")	
	menu_additem(menu, "Przesun do mnie")	
	menu_display(id, menu, 0)
}
public menuMove_2(id, menu, item){
	if( item == MENU_EXIT ){
		barrierSize(id)
		return PLUGIN_CONTINUE
	}
	new Float:fOrigin[3]
	pev(gBarriers[gBarrier[id]], pev_origin, fOrigin)
	new Float:fBarrierSizeMin[3],Float:fBarrierSizeMax[3]
	pev(gBarriers[gBarrier[id]], pev_mins, fBarrierSizeMin)
	pev(gBarriers[gBarrier[id]], pev_maxs, fBarrierSizeMax)
	switch(item){
		case 0:{
			fOrigin[0]+=userMoveFor[id]
		}	
		case 1:{
			fOrigin[0]-=userMoveFor[id]
		}	
		case 2:{
			fOrigin[1]+=userMoveFor[id]
		}	
		case 3:{
			fOrigin[1]-=userMoveFor[id]
		}
		case 4:{
			fOrigin[2]+=userMoveFor[id]
		}	
		case 5:{
			fOrigin[2]-=userMoveFor[id]
		}		
		case 6:{			
			pev(id, pev_origin, fOrigin)
			engfunc( EngFunc_SetSize, gBarriers[gBarrier[id]] , fBarrierSizeMin, fBarrierSizeMax );
		}
	}	
	set_pev(gBarriers[gBarrier[id]], pev_origin, fOrigin)
	menuMove(id)
	return PLUGIN_CONTINUE
}


new Float:gfDistance[33];
new giCatched[33];
new giMarked[33];

BOX_CreateAnchors(ent){
	new Float:fMins[3], Float:fMaxs[3];
	pev(ent, pev_absmin, fMins);
	pev(ent, pev_absmax, fMaxs);
	
	BOX_CreateAnchorsEntity(ent, 0b000, fMins[0], fMins[1], fMins[2]);
	BOX_CreateAnchorsEntity(ent, 0b001, fMins[0], fMaxs[1], fMins[2]);
	BOX_CreateAnchorsEntity(ent, 0b010, fMaxs[0], fMins[1], fMins[2]);
	BOX_CreateAnchorsEntity(ent, 0b011, fMaxs[0], fMaxs[1], fMins[2]);
	BOX_CreateAnchorsEntity(ent, 0b100, fMins[0], fMins[1], fMaxs[2]);
	BOX_CreateAnchorsEntity(ent, 0b101, fMins[0], fMaxs[1], fMaxs[2]);
	BOX_CreateAnchorsEntity(ent, 0b110, fMaxs[0], fMins[1], fMaxs[2]);
	BOX_CreateAnchorsEntity(ent, 0b111, fMaxs[0], fMaxs[1], fMaxs[2]);
}
BOX_CreateAnchorsEntity(box, num, Float:x, Float:y, Float:z){	
	new Float:fOrigin[3];
	fOrigin[0] = x;
	fOrigin[1] = y;
	fOrigin[2] = z;
		
	new ent = create_entity("info_target");
	entity_set_string(ent, EV_SZ_classname, "box_anchor");
		
	entity_set_model(ent, gszModel);
	entity_set_origin(ent, fOrigin);
		
	entity_set_size(ent, Float:{-4.5, -4.5, -4.5}, Float:{4.5, 4.5, 4.5});
		
	set_pev(ent, pev_solid, SOLID_BBOX);
	set_pev(ent, pev_movetype, MOVETYPE_NOCLIP);
	set_pev(ent, pev_owner, box);
		
	set_pev(ent, pev_iuser4, num);
	
	set_pev(ent, pev_scale, 0.05);
		
	set_rendering(ent, kRenderFxPulseFast, 120,250,50, kRenderTransAdd, 255);
}
BOX_RemoveAnchors(){
	new ent = -1;
	/*while((ent = find_ent_by_owner(ent, "box_anchor", box)))	remove_entity(ent);*/
	while ((ent = find_ent_by_class(ent, "box_anchor"))){
		if (pev_valid(ent)){
				remove_entity(ent);
		}
	}
	
}
public fwTraceLine(const Float:v1[], const Float:v2[], fNoMonsters, pentToSkip, ptr){
	if(is_user_alive(pentToSkip)){
		
		if(userEditing && has_flag(pentToSkip, "d")){
			
			new ent = get_tr2(ptr, TR_pHit);
			
			if(!is_valid_ent(ent)) {
				BOX_AnchorMoveUnmark(pentToSkip, giMarked[pentToSkip]);
				return FMRES_IGNORED;
			}
				
			if(giCatched[pentToSkip]){
				if(pev(pentToSkip, pev_button)&IN_USE){
					BOX_AnchorMoveProcess(pentToSkip, giCatched[pentToSkip]);
				}
				else{
					BOX_AnchorMoveUninit(pentToSkip, giCatched[pentToSkip]);
				}
			}
			else{
				new szClass[32];
				pev(ent, pev_classname, szClass, 31);
				if(equal(szClass, "box_anchor")){
					if(pev(pentToSkip, pev_button)&IN_USE)					
						BOX_AnchorMoveInit(pentToSkip, ent);
					else BOX_AnchorMoveMark(pentToSkip, ent);	
				}
				else BOX_AnchorMoveUnmark(pentToSkip, giMarked[pentToSkip]);	
			}
		}
	}
	return FMRES_IGNORED;
}
public fwPlayerPreThink(id){
	if(userEditing &&  has_flag(id, "d")){
		//set_pdata_float(id, 83 , 1.0, 5);		
		if(is_valid_ent(giCatched[id])){
			if(pev(id, pev_button)&IN_USE) BOX_AnchorMoveProcess(id, giCatched[id]);
			else BOX_AnchorMoveUninit(id, giCatched[id]);
			
		}
	}
}
BOX_AnchorMoveInit(id, ent){
	gfDistance[id] = entity_range(id, ent);
	giCatched[id] = ent;
	set_rendering(ent, kRenderFxGlowShell, 255, 32, 32, kRenderTransAdd, 255);
}
BOX_AnchorMoveMark(id, ent){
	giMarked[id] = ent;
	set_pev(ent, pev_scale, 0.06);
}
BOX_AnchorMoveUnmark(id, ent){
	giMarked[id] = 0;
	set_pev(ent, pev_scale, 0.05);
}
BOX_AnchorMoveProcess(id, ent){
	if(giCatched[id] != ent)
		BOX_AnchorMoveInit(id, ent);
	
	if( (pev(id, pev_button)& IN_ATTACK) ){
		
		client_print(id, print_center, "--Oddalanie--")
		gfDistance[id] +=  1.5;
		
	}
	if( (pev(id, pev_button) & IN_ATTACK2) ){
		
		client_print(id, print_center, "--Przyblizanie--")
		gfDistance[id] -= 1.5;		
		
	}
	
	new Float:fVec[3];
	pev(id, pev_v_angle, fVec);
	angle_vector(fVec, ANGLEVECTOR_FORWARD, fVec);
	
	xs_vec_mul_scalar(fVec, gfDistance[id], fVec);
	
	new Float:fOrigin[3];
	pev(id, pev_origin, fOrigin);
	
	new Float:fView[3];
	pev(id, pev_view_ofs, fView);
	
	xs_vec_add(fOrigin, fView, fOrigin);
	xs_vec_add(fOrigin, fVec, fVec);
	
	set_pev(ent, pev_origin, fVec);	
	
	new box = pev(ent, pev_owner);
	new num1 = pev(ent, pev_iuser4);
	
	new num2 = (~num1)&0b111;
	new ent2 = BOX_GetAnchor(box, num2);
	
	new Float:fVec2[3];
	pev(ent2, pev_origin, fVec2);
	
	BOX_UpdateSize(box, fVec, fVec2, num1);
}

BOX_UpdateSize(box, const Float:fVec[3], const Float:fVec2[3], anchor = -1){
	new Float:fMins[3];
	fMins[0] = floatmin(fVec[0], fVec2[0]);
	fMins[1] = floatmin(fVec[1], fVec2[1]);
	fMins[2] = floatmin(fVec[2], fVec2[2]);
	
	new Float:fMaxs[3];
	fMaxs[0] = floatmax(fVec[0], fVec2[0]);
	fMaxs[1] = floatmax(fVec[1], fVec2[1]);
	fMaxs[2] = floatmax(fVec[2], fVec2[2]);
	

	anchor != 0b000 && BOX_UpdateAnchorsEntity(box, 0b000, fMins[0], fMins[1], fMins[2]);
	anchor != 0b001 && BOX_UpdateAnchorsEntity(box, 0b001, fMins[0], fMaxs[1], fMins[2]);
	anchor != 0b010 && BOX_UpdateAnchorsEntity(box, 0b010, fMaxs[0], fMins[1], fMins[2]);
	anchor != 0b011 && BOX_UpdateAnchorsEntity(box, 0b011, fMaxs[0], fMaxs[1], fMins[2]);
	anchor != 0b100 && BOX_UpdateAnchorsEntity(box, 0b100, fMins[0], fMins[1], fMaxs[2]);
	anchor != 0b101 && BOX_UpdateAnchorsEntity(box, 0b101, fMins[0], fMaxs[1], fMaxs[2]);
	anchor != 0b110 && BOX_UpdateAnchorsEntity(box, 0b110, fMaxs[0], fMins[1], fMaxs[2]);
	anchor != 0b111 && BOX_UpdateAnchorsEntity(box, 0b111, fMaxs[0], fMaxs[1], fMaxs[2]);
	
	new Float:fOrigin[3];
	xs_vec_add(fMaxs, fMins, fOrigin);
	xs_vec_mul_scalar(fOrigin, 0.5, fOrigin);
	
	xs_vec_sub(fMaxs, fOrigin, fMaxs);
	xs_vec_sub(fMins, fOrigin, fMins);
	
	entity_set_origin(box, fOrigin);
	entity_set_size(box, fMins, fMaxs);
}
BOX_AnchorMoveUninit(id, ent){	
	gfDistance[id] = 0.0;
	giCatched[id] = 0;
	
	set_rendering(ent, kRenderFxNone, 120,250,50, kRenderTransAdd, 255);
}
BOX_GetAnchor(box, num){
	new ent = 0;
	new a = -1;
	while((a = find_ent_by_owner(a, "box_anchor", box))){
		if(pev(a, pev_iuser4) == num){
			ent = a;
			break;
		}
	}
	return ent;
}
BOX_UpdateAnchorsEntity(box, num, Float:x, Float:y, Float:z){
	new ent = BOX_GetAnchor(box,  num);
	
	if(is_valid_ent(ent)){
		new Float:fOrigin[3];
		fOrigin[0] = x;
		fOrigin[1] = y;
		fOrigin[2] = z;
		
		entity_set_origin(ent, fOrigin);
	}
}
